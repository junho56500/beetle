UML Class Diagram

01. 상속 (Inheritance)

02. 인터페이스 구현 (Interface Implimentation)

03. 연관 (Association) : general 관계 그냥 사용하고 있는 관계
한 클래스가 다른 클래스를 사용한다. 
때문에 두 클래스 사이의 life time은 전혀 상관이 없다. 
각각 독립적으로 생성되고연결이 될 수도, 연결이 되지 않을 수도 있다.

ex)class Printer --------- class Student

class Printer {
public:
    void print(const std::string& doc) {
        // printing logic
    }
};

class Student {
public:
    // Association: The Printer is passed in as an argument.
    // The Student doesn't own or manage the Printer's lifetime.
    void submitAssignment(Printer& p) {
        p.print("My Assignment");
    }
};

04. Aggregation

ex)class Book <>------------ class Library

class Book {
public:
    std::string title;
    Book(std::string t) : title(t) {}
};

class Library {
private:
    // Aggregation: The Library holds pointers/references to Book objects.
    // The Library doesn't uniquely own the Books (shared_ptr implies shared ownership).
    std::vector<std::shared_ptr<Book>> books; 

public:
    void addBook(std::shared_ptr<Book> book) {
        books.push_back(book);
    }
    // When the Library object is destroyed, the Books may still exist
    // if other shared_ptr instances are pointing to them.
};


05. 구성 (Composition) : 객체의 생성과 소멸 시기가 동일하다.
즉 Car 클래스 생성자 내에서 Engine 클래스를 생성한다.

ex)class Car <<>>------------- class Engine

class Engine {
public:
    Engine() { /* Engine created */ }
    ~Engine() { /* Engine destroyed */ }
};

class Car {
private:
    // Composition: The Car exclusively owns the Engine.
    // std::unique_ptr guarantees the Engine's lifetime is tied to the Car.
    std::unique_ptr<Engine> engine_;

public:
    // The Car creates and owns its own Engine.
    Car() : engine_(std::make_unique<Engine>()) {} 
    
    // When the Car is destroyed (at the end of its scope), 
    // the unique_ptr automatically destroys the Engine.
};


06. 의존 (Dependency)객체의 생성과 소멸 시기와는 연관이 없다. 

ex)Car - - - - - - - - - > Airconclass

Car{
    ...
public:
    void Air( Aircon con){
        con.turnOn();   // Aircon 클래스를 인자로 받아 메소드를 내부적으로 호출한다.
                        // Aircon 의 turnOn 의 정의가 바뀌면
                        // Car 에 영향을 주게 되므로 의존 관계에 있다고 말한다.
    }
};
