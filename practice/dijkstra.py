import heapq

def dijkstra(graph, start_node):
    """
    Implements Dijkstra's algorithm to find the shortest paths from a single
    source node to all other nodes in a weighted graph.

    Args:
        graph (dict): A dictionary representing the graph. Each key is a node,
                      and its value is another dictionary where keys are
                      neighboring nodes and values are the weights of the edges
                      to those neighbors.
                      Example: {'A': {'B': 1, 'C': 4}, 'B': {'A': 1, 'C': 2, 'D': 5}}
        start_node: The starting node for finding shortest paths.

    Returns:
        tuple: A tuple containing two dictionaries:
               - distances (dict): Shortest distance from start_node to each node.
                                   Nodes unreachable from start_node will not be present.
               - predecessors (dict): Stores the predecessor node for each node
                                      in the shortest path from the start_node.
                                      Useful for reconstructing the path.
    """
    # Initialize distances with infinity for all nodes and 0 for the start_node
    distances = {node: float('infinity') for node in graph}
    distances[start_node] = 0

    # Priority queue to store (distance, node) tuples.
    # It will always extract the node with the smallest distance.
    priority_queue = [(0, start_node)]

    # Dictionary to store predecessors to reconstruct the shortest path
    predecessors = {}

    while priority_queue:
        # Extract the node with the smallest distance from the priority queue
        current_distance, current_node = heapq.heappop(priority_queue)

        # If we've already found a shorter path to this node, skip it
        if current_distance > distances[current_node]:
            continue

        # Explore neighbors of the current node
        for neighbor, weight in graph[current_node].items():
            distance = current_distance + weight

            # If a shorter path to the neighbor is found
            if distance < distances[neighbor]:
                distances[neighbor] = distance
                predecessors[neighbor] = current_node
                heapq.heappush(priority_queue, (distance, neighbor))

    # Filter out unreachable nodes (those still at infinity distance)
    # and return only reachable nodes' distances
    reachable_distances = {node: dist for node, dist in distances.items() if dist != float('infinity')}

    return reachable_distances, predecessors

def reconstruct_path(predecessors, start_node, end_node):
    """
    Reconstructs the shortest path from the start_node to the end_node
    using the predecessors dictionary generated by Dijkstra's algorithm.

    Args:
        predecessors (dict): The dictionary of predecessors from Dijkstra's algorithm.
        start_node: The starting node of the path.
        end_node: The destination node of the path.

    Returns:
        list: A list representing the shortest path from start_node to end_node.
              Returns an empty list if no path exists.
    """
    path = []
    current = end_node
    while current is not None and current in predecessors:
        path.append(current)
        current = predecessors[current]
    if current == start_node: # Add the start node if the path was successfully traced back to it
        path.append(start_node)
        return path[::-1] # Reverse the path to get it from start to end
    return [] # Return empty list if end_node is unreachable or start_node wasn't in path

# --- Example Usage ---
if __name__ == "__main__":
    # Define a graph as an adjacency list with weights
    graph = {
        'A': {'B': 1, 'C': 4},
        'B': {'A': 1, 'C': 2, 'D': 5},
        'C': {'B': 2, 'D': 1},
        'D': {'B': 5, 'C': 1, 'E': 3},
        'E': {'D': 3}
    }

    start_node = 'A'
    distances, predecessors = dijkstra(graph, start_node)

    print(f"Shortest distances from node '{start_node}':")
    for node, dist in distances.items():
        print(f"  To {node}: {dist}")

    print("\nPredecessors for path reconstruction:")
    for node, pred in predecessors.items():
        print(f"  {node}: {pred}")

    print("\n--- Path Reconstruction Examples ---")

    # Path from A to E
    path_A_to_E = reconstruct_path(predecessors, start_node, 'E')
    print(f"Shortest path from '{start_node}' to 'E': {path_A_to_E}")

    # Path from A to C
    path_A_to_C = reconstruct_path(predecessors, start_node, 'C')
    print(f"Shortest path from '{start_node}' to 'C': {path_A_to_C}")

    # Path to an unreachable node (if there was one, e.g., 'F')
    # Let's add an isolated node to demonstrate
    graph_with_isolated = {
        'A': {'B': 1},
        'B': {'A': 1},
        'X': {'Y': 1}, # Isolated
        'Y': {'X': 1}  # Isolated
    }
    distances_iso, predecessors_iso = dijkstra(graph_with_isolated, 'A')
    path_A_to_Y = reconstruct_path(predecessors_iso, 'A', 'Y')
    print(f"\nShortest path from 'A' to 'Y' (unreachable): {path_A_to_Y}")

    # Another example graph
    graph2 = {
        '0': {'1': 4, '7': 8},
        '1': {'0': 4, '2': 8, '7': 11},
        '2': {'1': 8, '3': 7, '5': 4, '8': 2},
        '3': {'2': 7, '4': 9, '5': 14},
        '4': {'3': 9, '5': 10},
        '5': {'2': 4, '3': 14, '4': 10, '6': 2},
        '6': {'5': 2, '7': 1, '8': 6},
        '7': {'0': 8, '1': 11, '6': 1, '8': 7},
        '8': {'2': 2, '6': 6, '7': 7}
    }
    start_node2 = '0'
    distances2, predecessors2 = dijkstra(graph2, start_node2)
    print(f"\nShortest distances from node '{start_node2}':")
    for node, dist in distances2.items():
        print(f"  To {node}: {dist}")

    path_0_to_4 = reconstruct_path(predecessors2, start_node2, '4')
    print(f"Shortest path from '{start_node2}' to '4': {path_0_to_4}")
